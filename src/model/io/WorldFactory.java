package model.io;

import java.util.ArrayList;
import java.util.HashMap;

import org.json.*;

import controller.parser.Command;
import controller.parser.CommandType;
import exceptions.AdjoiningRoomNotFoundException;
import exceptions.WorldEntityNotFoundException;

import model.world.*;
import model.objective.*;
import model.world.Character;


/**
 * Used to convert worlds, stored in JSON, into memory so that they can be
 * played within the game.
 * @author Llamas / Yaks
 */
public class WorldFactory {
	/*
	 * Instance variables
	 */
	private HashMap<String, WorldEntity> worldEntities;			// Map's uniqueId's to WorldEntities
	
	
	
	/**
	 * Constructor - Creates the WorldFactory
	 */
	public WorldFactory() {
		// Initialise the fields
		this.worldEntities = new HashMap<String, WorldEntity>();
	}
	
	
	
	/**
	 * Creates the World object and its child objects
	 * @param jsonString The JSON world data to be used
	 * @return The new World
	 * @throws JSONException 					Thrown if there is a problem with the input JSON
	 * @throws WorldEntityNotFoundException 	Thrown if a WorldEntity is referenced which doesn't exist
	 * @throws AdjoiningRoomNotFoundException 	
	 */
	public World createWorld(String jsonString) throws JSONException, WorldEntityNotFoundException, AdjoiningRoomNotFoundException {

		//System.out.println("Creating world...");
		
		//convert the string to a JSON object
		JSONObject json = new JSONObject(jsonString);
		
		//throw away any previously created entity map (if any)
		this.worldEntities.clear();
		
		//load the rooms
		JSONArray roomArray = json.getJSONArray("rooms");
		ArrayList<Room> rooms = this.getRooms(roomArray);
	
		//get the player data
		JSONObject playerObject = json.getJSONObject("player");
		Player worldPlayer = this.createPlayer(playerObject);
		
		//load the world attributes
		String worldAuthor = json.getString("author");
		String worldCreated = json.getString("created");
		String worldDescription = json.getString("description");
		String worldName = json.getString("name");
		
		//create the world
		World world = new World(worldName, worldDescription, worldCreated, worldAuthor, worldPlayer);
		
		//insert the rooms
		for(Room room : rooms) {
			world.addRoom(room);
		}
		
		//load the objectives
		JSONArray objectivesArray = json.getJSONArray("objectives");
		ArrayList<Objective> objectives = this.getObjectives(objectivesArray);
		
		//insert the objectives
		for(Objective objective : objectives) {
			world.addObjective(objective);
		}
			
		return world;
	}
	
	
	/**
	 * getObjectives - Returns an ArrayList of Objectives created from a JSONArray of objectives from the world JSON
	 * 
	 * @param objectivesArray A JSONArray containing data created by Objective.toJSONObject()
	 * @return An ArrayList of Objectives to be inserted into a World (by WorldFactory)
	 * @throws JSONException Thrown if there is a problem with the input JSON
	 * @throws WorldEntityNotFoundException Thrown if a WorldEntity is referenced which doesn't exist
	 */
	private ArrayList<Objective> getObjectives(JSONArray objectivesArray) throws JSONException, WorldEntityNotFoundException {
		
		ArrayList<Objective> objectives = new ArrayList<Objective>();
		
		for(int index = 0; index < objectivesArray.length(); index++ ) {
			Objective objective = this.createObjective(objectivesArray.getJSONObject(index));
			objectives.add(objective);
		}
		
		return objectives;
	}

	
	/**
	 * createObjective - Creates an Objective object from a JSONObject containing Objective data 
	 * @param jsonObject The Objective in json form, generated by Objective.toJSONObject()
	 * @return The new Objective object
	 * @throws JSONException Thrown if there is a problem with the input JSON
	 * @throws WorldEntityNotFoundException Thrown if a WorldEntity is referenced which doesn't exist
	 */
	public Objective createObjective(JSONObject jsonObject) throws JSONException, WorldEntityNotFoundException {
	
		String objectiveDescription = jsonObject.getString("description");
		String objectiveOnComplete = jsonObject.getString("onCompleteMessage");
		Command objectiveCommand = this.createCommand(jsonObject.getJSONObject("command"));
		
		Objective objective = new Objective(objectiveDescription, objectiveOnComplete, objectiveCommand);
		
		return objective;
	}

	
	/**
	 * createCommand - Creates a Command object from an input JSONObject
	 * @param jsonObject The JSONObject containing Command data
	 * @return The new Command
	 * @throws JSONException Thrown if there is a problem with the input JSON
	 * @throws WorldEntityNotFoundException Thrown if a WorldEntity is referenced which doesn't exist
	 */
	public Command createCommand(JSONObject jsonObject) throws JSONException, WorldEntityNotFoundException {
		//{"entity-id":"entity0.unique-id","commandType":"ATTACK"}
		String entityId = jsonObject.getString("entity-id");
		CommandType commandType = CommandType.valueOf(jsonObject.getString("commandType"));
		
		WorldEntity worldEntity = this.worldEntities.get(entityId);
		
		if(worldEntity == null) {
			throw new WorldEntityNotFoundException(entityId);
		}
				
		Command command = new Command(commandType, worldEntity);		
		return command;
	}

	
	/**
	 * createPlayer - Creates a Player from an input JSONObject containing the Player data
	 * 
	 * @param playerObject		The player object in JSON form
	 * @return					The new Player object
	 * @throws JSONException	Thrown if there is a problem with the input JSON
	 * @throws AdjoiningRoomNotFoundException 
	 */
	public Player createPlayer(JSONObject playerObject) throws JSONException, AdjoiningRoomNotFoundException {
		
		//load the visited rooms {"cargobayb","cargobaya"}
		JSONArray visitedRoomsArray = playerObject.getJSONArray("visitedRooms");
		ArrayList<Room> visitedRooms = new ArrayList<Room>();
				
			//for the length of the visited rooms array
			for(int i = 0; i < visitedRoomsArray.length();i++){
				// get the i'th string in the array
				String roomID = visitedRoomsArray.getString(i);	
				// And look up the room in the worldEntites HashMap with matching roomID
				Room room = (Room) this.worldEntities.get(roomID);	
				//Add that room to the visitedRooms ArrayList
				visitedRooms.add(room);
			}
				
		String playerRoomUniqueId = playerObject.getString("currentRoom");
		String playerWeaponId = playerObject.optString("wieldedWeapon");
		int playerCurrentHealth = playerObject.getInt("currentHealth");
		int playerMaxHealth = playerObject.getInt("maxHealth");
		
		Player player = new Player(playerMaxHealth,
			(Weapon) this.worldEntities.get(playerWeaponId), 
			(Room) this.worldEntities.get(playerRoomUniqueId)
		);
		
		player.setCurrentHealth(playerCurrentHealth);
		
		//Add players visitedRooms from thevistedRooms ArrayList
		for(Room room:visitedRooms){
			player.addToVisitedRooms(room);
		}
		
		
		JSONObject playerInventoryObject = playerObject.getJSONObject("inventory");
		JSONArray playerInventoryArray = playerInventoryObject.getJSONArray("items");
		
		this.loadInventoryContent(player.getInventory(), playerInventoryArray);
		
		//load the weapon last as it depends on the inventory being loaded (and Items being created)
		if(!playerWeaponId.isEmpty()) {
			player.setWieldedWeapon((Weapon)this.worldEntities.get(playerWeaponId));
		}
		
		this.loadWorldEntity(player, playerObject);
		return player;
	}

	
	/**
	 * getRooms - Takes a JSONArray containing Room data and outputs an ArrayList of the created Rooms
	 * @param roomArray The JSONArray containing the Room data
	 * @return The ArrayList of newly created Rooms
	 * @throws JSONException Thrown if there is a problem with the input JSON
	 * @throws AdjoiningRoomNotFoundException Thrown if an adjoining room is referenced which does not exist
	 */
	public ArrayList<Room> getRooms(JSONArray roomArray) throws JSONException, AdjoiningRoomNotFoundException {
		
		ArrayList<Room> rooms = new ArrayList<Room>();
		
		for(int index = 0; index < roomArray.length(); index++) {
			
			JSONObject roomObject = roomArray.getJSONObject(index);
			Room room = this.createRoom(roomObject);
			rooms.add(room);
			
			//The new room is automatically added to the list of Rooms when it is created in createRoom().
		}
		
		
		
		for(int index = 0; index < roomArray.length(); index++) {
			
			JSONObject roomObject = roomArray.getJSONObject(index);
			JSONArray adjoiningArray = roomObject.getJSONArray("adjoiningRooms");
			
			Room room = (Room) this.worldEntities.get(roomObject.getString("uniqueId"));
			
			
			//loop through the adjoining room Ids
			for(int joinIndex = 0; joinIndex < adjoiningArray.length(); joinIndex++) {
				String roomId = adjoiningArray.getString(joinIndex);
				
				//add each adjoining room object, getting it from the map by its id
				Room adjoiningRoom = (Room) this.worldEntities.get(roomId);
				
				if(adjoiningRoom == null) {
					throw new AdjoiningRoomNotFoundException(roomId);
				}
				room.addAdjoiningRoom(adjoiningRoom);
			}
		}
		return rooms;
	}
	
	
	/**
	 * Add a WorldEntity to the map so that it can be accessed via its uniqueId
	 * @param worldEntity The entity to add
	 */
	public void addWorldEntity(WorldEntity worldEntity) {
		this.worldEntities.put(worldEntity.getUniqueId(), worldEntity);	
	}

	
	/**
	 * createRoom - Creates a Room object from Room data in a JSONObject
	 * 
	 * calls: createRoomInventory, loadWorldEntity
	 * 
	 * @param jsonObject	The Room data in JSON form
	 * @return The new Room	
	 * @throws JSONException Thrown if an adjoining room is referenced which does not exist
	 */
	public Room createRoom(JSONObject jsonObject) throws JSONException {
		//create the inventory
		RoomInventory roomInventory = this.createRoomInventory(jsonObject.getJSONObject("inventory"));
		
		//create the room
		Room room = new Room(roomInventory);
		
		//load the WorldEntity data into the Room
		this.loadWorldEntity(room, jsonObject);
		
		//return the new room
		return room;
	}
	
	
	/**
	 * createRoomInventory - Creates a new RoomInventory object containing any Items or Npcs
	 * @param jsonObject The JSONObject containing the RoomInventory data
	 * @throws JSONException Thrown if there is a problem with the input JSON
	 */
	public RoomInventory createRoomInventory(JSONObject jsonObject) throws JSONException {
		//System.out.println("--- Loading RoomInventory...");
		RoomInventory roomInventory = new RoomInventory();
		
		this.loadInventoryContent(roomInventory, jsonObject.getJSONArray("items"));
		this.loadRoomInventoryCharacters(roomInventory, jsonObject.getJSONArray("characters"));
		
		return roomInventory;
	}
	
	
	/**
	 * loadRoomInventoryCharacters - Loads a JSONArray containing Characters into a RoomInventory object 
	 * 
	 * calls: createCharacter
	 * 
	 * @param roomInventory		The RoomInventory
	 * @param jsonArray			The array of Characters in JSON form
	 * @throws JSONException	Thrown if there is a problem with the input JSON
	 */
	private void loadRoomInventoryCharacters(RoomInventory roomInventory, JSONArray jsonArray) throws JSONException {
		
		//System.out.print(" characters={ ");
		
		//loop through the array of Npcs in the JSON
		for(int index = 0; index < jsonArray.length(); index++) {
			JSONObject jsonCharacter = jsonArray.getJSONObject(index);
						
			//create the character and add it to the room
			Character character = this.createNpc(jsonCharacter);
			roomInventory.addCharacter(character);
			
			//System.out.print(character.getUniqueId() + (index+1 < jsonArray.length() ? ", " : " "));
			
		}
		
		//System.out.println("}");
		
		
	}
	
	/**
	 * createCharacter - Creates a Character object from an input JSONObject
	 * @param jsonObject The JSONObject
	 * @return The new Character
	 * @throws JSONException Thrown if there is a problem with the input JSON
	 */
	public Character createNpc(JSONObject jsonObject) throws JSONException {
		
		/*{ "narratives":["blah","blah"],
			"description":"char0.description",
			"name":"char0.name",
			"currentHealth":50,
			"maxHealth":2147483647,
			"type":"friendly",
			"uniqueId":"char0.unique-id",
			"inventory":{"items":[...], "maxItems":... }
		}*/
		
		
		//load the narratives
		ArrayList<String> narrativeArray = new ArrayList<String>();
		
		JSONArray narrativeJSONArray = jsonObject.getJSONArray("narratives");
		for(int index = 0; index < narrativeJSONArray.length(); index++ ) {
				narrativeArray.add(narrativeJSONArray.getString(index));
		}
		
		// Create the character based on whether it is friendly or hostile
		Character character;
		
		if(jsonObject.getString("type").equals("friendly")) {
			character = new FriendlyNpc(narrativeArray);
		}
		else if(jsonObject.getString("type").equals("hostile")) {
			// It is hostile so load in the attack probability
			double characterAttackProbability = jsonObject.getDouble("attackProbability");
			
			// Load the health attributes
			int characterCurrentHealth = jsonObject.optInt("currentHealth");
			int characterMaxHealth = jsonObject.optInt("maxHealth");
			
			if(characterMaxHealth == 0) {
				// Max health not defined - set to current health if defined, else infinity
				characterMaxHealth = characterCurrentHealth != 0 ? characterCurrentHealth : Integer.MAX_VALUE;
			}

			character = new HostileNpc(characterMaxHealth, narrativeArray, null, characterAttackProbability);
			
			if(characterCurrentHealth != 0) {
				// Set character's current health if defined (default upon instantiation to equal maxHealth)
				character.setCurrentHealth(characterCurrentHealth);
			}
		}
		else {
			throw new JSONException("Error: Unsuported Character type: " + jsonObject.getString("type"));
		}
		
		
		//load the inventory
		
		JSONObject characterInventoryObject = jsonObject.getJSONObject("inventory");
		
		this.loadCharacterInventory(character.getInventory(), characterInventoryObject);
		
		this.loadWorldEntity(character, jsonObject);
		
		//load weapon last as it depends on inventory being loaded
		
		String weaponId = jsonObject.optString("wieldedWeapon");
		
		if(!weaponId.isEmpty()) {
			Weapon characterWeapon = (Weapon)this.worldEntities.get(weaponId);
			character.setWieldedWeapon(characterWeapon);
		}
		
		return character;
	}
	
	
	/**
	 * loadInventoryContent - Loads Items into an Inventory object from an input JSONArray
	 * 
	 * calls: createItem
	 * @param inventory	The Inventory to be filled
	 * @param jsonArray	A JSON array containing the Items in JSON form
	 * @throws JSONException	Thrown if there is a problem with the input JSON
	 */
	public void loadInventoryContent(Inventory inventory, JSONArray jsonArray) throws JSONException {
		//System.out.print("items={ ");
		
		for(int index = 0; index < jsonArray.length(); index++) {
			JSONObject itemJSON = jsonArray.getJSONObject(index);
			
			Item item = this.createItem(itemJSON);
			
			//System.out.print(item.getUniqueId() + (index+1 < jsonArray.length() ? ", " : " ") );
			
			inventory.addItem( item );
		}
		//System.out.print("} ");
	}
	
	/**
	 * loadCharacterInventory - Loads a CharacterInventory from JSON
	 * @param inventory		The CharacterInventory to be filled
	 * @param jsonObject	The inventory in JSON form
	 * @throws JSONException	Thrown if there is a problem with the input JSON
	 */
	public void loadCharacterInventory(CharacterInventory inventory, JSONObject jsonObject) throws JSONException {
		//{"items":[...], "maxItems":... }
		
		int maxItems;
		if(jsonObject.isNull("maxItems")) {
			maxItems = Integer.MAX_VALUE;			// Default item limit
		}
		else {
			maxItems = jsonObject.getInt("maxItems");
		}
		
		inventory.setMaxItems(maxItems);
		loadInventoryContent(inventory, jsonObject.getJSONArray("items"));

	}
	
	
	/**
	 * createItem - Creates a new Item from an input JSONObject
	 * @param jsonObject The JSONObject
	 * @return The new Item
	 * @throws JSONException Thrown if there is a problem with the input JSON
	 */
	public Item createItem(JSONObject jsonObject) throws JSONException {
		String itemType = jsonObject.getString("type");
		
		Item item;
		
		if(itemType.equals("item")) {
			boolean itemUsable = jsonObject.getBoolean("usable");
			boolean itemCarriable = jsonObject.getBoolean("carriable");
			boolean itemAttackable = jsonObject.optBoolean("attackable", true);	 // Attackable by default
			
			item = new Item(itemCarriable, itemUsable, itemAttackable);
		} 
		else if(itemType.equals("weapon")) {
			int minDamage = jsonObject.getInt("minDamage");
			int maxDamage = jsonObject.getInt("maxDamage");
			int easeOfUse = jsonObject.getInt("easeOfUse");
			item = new Weapon(minDamage, maxDamage, easeOfUse);
		} 
		else if(itemType.equals("medicine")) {
			item = new Medicine();
		} 
		else {
			throw new JSONException("Error: Unknown Item type!");
		}
		
		// Load the transformsTo object
		if (jsonObject.has("transformsTo")) {
			Item transforms = createItem(jsonObject.getJSONObject("transformsTo"));
			item.setTransformsTo(transforms);
		}
		
		this.loadWorldEntity(item, jsonObject);
		
		return item;
	}
	
	
	/**
	 * loadWorldEntity - Loads WorldEntity data into a WorldEntity (name, uniqueId, description) based on data from a JSONObject
	 * @param entity The WorldEntity to be modified
	 * @param jsonObject The JSONObject
	 * @throws JSONException Thrown if there is a problem with the input JSON
	 */
	public void loadWorldEntity(WorldEntity entity, JSONObject jsonObject) throws JSONException {
		entity.setDescription(jsonObject.getString("description"));
		entity.setName(jsonObject.getString("name"));
		entity.setUniqueId(jsonObject.getString("uniqueId"));
		
		//add the entity to the entity map
		addWorldEntity(entity);
	}	
}
